/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32l053xx.h"
#include "core_cm0plus.h"

// Prototipos de las funciones
void SystemClock_Config(void);
void GPIO_Init(void);
void TIM2_Init(void);
void TIM3_Init(void);
void TIM21_Init(void);
void TIM6_Int(void);

int main(void) {
	// Configuración del sistema y periféricos
	SystemClock_Config();  // Configurar el reloj del sistema
	GPIO_Init();           // Inicializar GPIO
	TIM2_Init();           // Inicializar TIM2
	TIM6_Init();           // Inicializar TIM6
	TIM21_Init();          // Inicializar TIM21

	// Activar los temporizadores
	TIM2->CR1 |= (1 << 0);   // Activar TIM2
	TIM6->CR1 |= (1 << 0);   // Activar TIM6
	TIM21->CR1 |= (1 << 0);  // Activar TIM21

	// Bucle infinito
	while (1) {
		// Verificar y limpiar el flag de actualización para TIM2
		if (TIM2->SR & 0x00000001) {
			TIM2->SR &= ~0x00000001; // Limpiar UIF (Update Interrupt Flag)
			GPIOA->ODR ^= (1 << 5);  // Conmutar PA5
		}

		// Verificar y limpiar el flag de actualización para TIM6
		if (TIM6->SR & 0x00000001) {
			TIM6->SR &= ~0x00000001; // Limpiar UIF
			GPIOA->ODR ^= (1 << 6);  // Conmutar PA6
		}

		// Verificar y limpiar el flag de actualización para TIM21
		if (TIM21->SR & 0x00000001) {
			TIM21->SR &= ~0x00000001; // Limpiar UIF
			GPIOA->ODR ^= (1 << 7);  // Conmutar PA7
		}
	}
}

void SystemClock_Config(void) {
	// Activar HSI (16 MHz) y esperar a que esté listo
	RCC->CR |= RCC_CR_HSION;  // Habilitar HSI
	while (!(RCC->CR & RCC_CR_HSIRDY))
		;  // Esperar hasta que HSI esté listo

	// Seleccionar HSI como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_HSI;  // Configurar HSI como el reloj del sistema
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
		;  // Esperar a que HSI sea el reloj del sistema
}

void GPIO_Init(void) {
	// Habilitar el reloj para GPIOA
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN;

	// Configurar PA5, PA6 y PA7 como salida
	GPIOA->MODER &= ~(GPIO_MODER_MODE5 | GPIO_MODER_MODE6 | GPIO_MODER_MODE7); // Limpiar bits de modo
	GPIOA->MODER |= (GPIO_MODER_MODE5_0 | GPIO_MODER_MODE6_0
			| GPIO_MODER_MODE7_0);  // Configurar como salida
}

void TIM2_Init(void) {
	// Habilitar el reloj para TIM2
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	// Configurar TIM2: PSC = 1600 - 1, ARR = 9999
	TIM2->PSC = 1600 - 1;  // Configurar prescaler a 1600
	TIM2->ARR = 9999;      // Configurar auto-recarga a 9999
}

void TIM6_Init(void) {
	// Habilitar el reloj para TIM6
	RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;

	// Configurar TIM6: PSC = 1600 - 1, ARR = 4999
	TIM6->PSC = 1600 - 1;  // Configurar prescaler a 1600
	TIM6->ARR = 4999;      // Configurar auto-recarga a 4999
}

void TIM21_Init(void) {
	// Habilitar el reloj para TIM21
	RCC->APB2ENR |= RCC_APB2ENR_TIM21EN;

	// Configurar TIM21: PSC = 1600 - 1, ARR = 2499
	TIM21->PSC = 1600 - 1;  // Configurar prescaler a 1600
	TIM21->ARR = 2499;      // Configurar auto-recarga a 2499
}

